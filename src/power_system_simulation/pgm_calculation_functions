import json
import math
import random

import pandas as pd
from power_grid_model import CalculationType, initialize_array
from power_grid_model.utils import json_deserialize
from power_grid_model.validation import assert_valid_batch_data

from power_system_simulation.graph_processing import GraphProcessor
from power_system_simulation.input_data_validity_check import reformat_pgm_to_array
from power_system_simulation.pgm_calculation_module import PGMcalculation
from power_system_simulation.ev_penetration_level import ev_penetration_calculation
from power_system_simulation.input_data_validity_check import *
from power_system_simulation.n_1_calculation import n_1_calculation_module
from power_system_simulation.optimal_tap_position import optimal_tap_pos

class NoActivePowerProfileProvided(Exception):
    """Raised when no active power profile is provided when it is needed"""

class NoReactivePowerProfileProvided(Exception):
    """Raised when no active power profile is provided when it is needed"""

class NoEVPowerProfileProvided(Exception):
    """Raised when no active power profile is provided when it is needed"""

class NoMetaDataProvided(Exception):
    """Raised when no active power profile is provided when it is needed"""

class PGMfunctions:
    def __init__(self,
        path_input_network_data: str,
        path_active_power_profile=0,
        path_reactive_power_profile=0,
        path_ev_active_power_profile=0,
        path_meta_data=0,):

        """Initializes the PGMfunctions class with paths to data."""
        self.path_input_network_data=path_input_network_data
        self.path_active_power_profile=path_active_power_profile
        self.path_reactive_power_profile=path_reactive_power_profile
        self.path_ev_active_power_profile=path_ev_active_power_profile
        self.path_meta_data=path_meta_data

    
    def create_pgm_model(self):
        # Create PGM model instance
        self.model = PGMcalculation()
        self.model.create_pgm(self.path_input_network_data)

        # Create array model of network
        with open(self.path_input_network_data, encoding="utf-8") as ind:
            input_network = json_deserialize(ind.read())
        vertex_ids, edge_ids, edge_vertex_id_pairs, edge_enabled, source_vertex_id = reformat_pgm_to_array(input_network)
        self.input_network_array_model = GraphProcessor(
            vertex_ids, edge_ids, edge_vertex_id_pairs, edge_enabled, source_vertex_id
        )

    def input_data_validity_check(self, test_case=0):
        if 0 not in (self.path_active_power_profile, self.path_reactive_power_profile, self.path_ev_active_power_profile, self.path_meta_data):
            validate_input_data(self.path_input_network_data, self.path_active_power_profile, self.path_reactive_power_profile, self.path_ev_active_power_profile, self.path_meta_data, test_case=test_case)
        else:
            if self.path_active_power_profile==0:
                raise NoActivePowerProfileProvided("No path to active power profile was provided")
            if self.path_reactive_power_profile==0:
                raise NoReactivePowerProfileProvided("No path to active power profile was provided")
            if self.path_ev_active_power_profile==0:
                raise NoEVPowerProfileProvided("No path to active power profile was provided")
            if self.path_meta_data==0:
                raise NoMetaDataProvided("No path to active power profile was provided")
    
    def create_batch_update_data(self, path_active_power_profile=0, path_reactive_power_profile=0) -> None:
        if path_active_power_profile!=0:
            pth_active=path_active_power_profile
        elif self.path_active_power_profile!=0:
            pth_active=self.path_active_power_profile
        else:
            raise NoActivePowerProfileProvided("No path to active power profile was provided")
        
        if path_reactive_power_profile!=0:
            pth_reactive=path_reactive_power_profile
        elif self.path_reactive_power_profile!=0:
            pth_reactive=self.path_reactive_power_profile
        else:
            raise NoReactivePowerProfileProvided("No path to reactive power profile was provided")
        
        if 0 not in (pth_active,pth_reactive):
            self.model.create_batch_update_data(pth_active, pth_reactive)
    
    def ev_penetration_level(self, penetration_level_percentage: int, path_ev_power_profile=0, path_meta_data=0, assert_valid_pwr_profile=False):
        if path_ev_power_profile!=0:
            pth_ev=path_ev_power_profile
        elif self.path_ev_active_power_profile!=0:
            pth_ev=self.path_ev_active_power_profile
        else:
            raise NoEVPowerProfileProvided("No path to EV power profile was provided")
        
        if path_meta_data!=0:
            pth_meta=path_meta_data
        elif self.path_meta_data!=0:
            pth_meta=self.path_meta_data
        else:
            raise NoReactivePowerProfileProvided("No path to meta data was provided")
        
        if 0 not in (pth_meta, pth_ev):
            df_voltages, df_line_loading=ev_penetration_calculation(self.model, self.input_network_array_model, self.path_input_network_data, pth_ev,pth_meta,penetration_level_percentage, assert_valid_pwr_profile=assert_valid_pwr_profile)
            return df_voltages, df_line_loading
            
    def n_1_calculation(self, line_id_disconnect:int ,reset_model_once_done=False):
        return n_1_calculation_module(self.model, self.input_network_array_model, line_id_disconnect, reset_model_once_done=reset_model_once_done)
    
    def find_optimal_tap_position(self, optimization_mode=0, path_active_power_profile=0, path_reactive_power_profile=0,threads=1):
        if path_active_power_profile!=0:
            pth_active=path_active_power_profile
        elif self.path_active_power_profile!=0:
            pth_active=self.path_active_power_profile
        else:
            raise NoActivePowerProfileProvided("No path to active power profile was provided")
        
        if path_reactive_power_profile!=0:
            pth_reactive=path_reactive_power_profile
        elif self.path_reactive_power_profile!=0:
            pth_reactive=self.path_reactive_power_profile
        else:
            raise NoReactivePowerProfileProvided("No path to reactive power profile was provided")
        
        if 0 in (path_active_power_profile, path_reactive_power_profile):
            self.create_batch_update_data(pth_active, pth_reactive)
        
        if 0 not in (pth_active,pth_reactive):
            return optimal_tap_pos(self.model, self.path_input_network_data, mode=optimization_mode, number_threads=threads)


PTH_INPUT_NETWORK_DATA = "tests/data/small_network/input/input_network_data.json"
PTH_ACTIVE_PROFILE = "tests/data/small_network/input/active_power_profile.parquet"
PTH_REACTIVE_PROFILE = "tests/data/small_network/input/reactive_power_profile.parquet"
PTH_EV_ACTIVE_POWER_PROFILE = "tests/data/small_network/input/ev_active_power_profile.parquet"
PTH_META_DATA = "tests/data/small_network/input/meta_data.json"


PGM_MODEL=PGMfunctions(PTH_INPUT_NETWORK_DATA,PTH_ACTIVE_PROFILE,PTH_REACTIVE_PROFILE,PTH_EV_ACTIVE_POWER_PROFILE,PTH_META_DATA)
PGM_MODEL.input_data_validity_check()
PGM_MODEL.create_pgm_model()
PGM_MODEL.create_batch_update_data(PTH_ACTIVE_PROFILE, PTH_REACTIVE_PROFILE)
PGM_MODEL.ev_penetration_level(50, PTH_EV_ACTIVE_POWER_PROFILE, PTH_META_DATA, assert_valid_pwr_profile=True)
PGM_MODEL.n_1_calculation(18,True)
PGM_MODEL.find_optimal_tap_position()